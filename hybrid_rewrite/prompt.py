import json

from typing import List, Dict


def get_prompt(version_str: str = "0_0_3"):
    current_globals = globals()
    func_name = f"build_prompt_v_{version_str}"
    return current_globals.get(func_name)


def build_prompt_v_0_0_3(query: str, examples: List[Dict[str, any]], **args) -> str:
    prompt_lines = [
        "在此前阶段，你基于用户的query生成了若干用于数据查询的DSL配置，现在，你需要根据当前用户的query以及相似query对应的DSL配置改写出当前query对应的DSL配置。",
        "以下是你所生成的历史DSL配置：\n",
    ]
    for ex in examples:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines.append(f"用户query：{_query}\nDSL配置：{_dsl}\n")

    prompt_lines += [
        "\n\n",
        "以下是当前你需要改写的新用户query：\n",
        f"用户query：{query}\n",
        "已知DSL配置和query以及表数据对应，请你根据生成的历史DSL配置中的映射关系为当前用户query生成真实可用的DSL配置，请勿生成历史DSL配置中不存在的配置项。你生成的配置格式应当为与历史DSL配置完全一致的JSON格式，并不附加任何额外信息。"
    ]
    return "\n".join(prompt_lines)


def build_prompt_v_0_0_4(query: str, examples: List[Dict[str, any]], **args) -> str:
    prompt_lines = [
        "在此前阶段，你基于用户的query生成了若干用于数据查询的DSL配置，现在，你需要根据当前用户的query以及相似query对应的DSL配置改写出当前query对应的DSL配置。",
        "此外这个环节会提供表规则需要基于`表规则`补充指标规则:",
        "## 指标规则的配置知识",
        "以下是提供给你的指标规则的配置知识，在后续规则配置流程中需要参照这份知识",

        "1. 字段数据类型：日期、日期时间、字符串、整数、浮点数、布尔值。",
        "2. 字段角色：维度、指标。",
        "维度包含定量值（例如名称、日期或地理数据）。可以使用维度进行分类、分段以及揭示数据中的详细信息。维度影响视图中的详细级别。",
        "指标包含可以测量的数字定量值，有确定的聚合状态。维度字段也可以应用聚合方式（计数、去重计数、最大值、最小值）形成指标，例如用户数可以是 用户名的去重计数。",
        "3. 指标聚合状态：已聚合、未聚合。",
        "已聚合：指标字段已经聚合，不需要再次聚合。",
        "未聚合：指标字段未聚合，需要确定聚合方式。聚合方式是 求和、计数、去重计数、平均值、最大值、最小值 中的一种。不同数据类型的字段可应用的聚合方式不同，具体是：",
        "a. 整数、浮点数：求和、计数、去重计数、平均值、最大值、最小值",
        "b. 字符串、日期、日期时间：计数、去重计数、最大值、最小值",
        "4. 高级计算-同环比：同环比计算不同时间区间的数据对比情况，需要确定同环比类型、对比结果类型及使用的时间维度。",
        "同环比类型从以下几种中选择一个：",
        "a. 环比-上期：本期数据对比上期数据，本期和上期是相邻的时间周期，例如今日和昨日数据、本周和上周数据、近3天和近6至4天数据",
        "b. 环比-上上期：本期数据对比上上期数据，例如本周周二对比上上周周二数据",
        " c. 周同比：本周对比上周同期数据，例如本周周二对比上周周二数据",
        "d. 月同比：本期数据对比上月同期数据，例如本月3日对比上月3日数据、本月10-20日数据对比上月10-20日数据",
        "e. 年同比：本期数据对比去年同期数据，例如本年9月3日对比去年9月3日数据、本年10月数据对比去年10月数据",
        "对比结果类型从以下几种中选择一个：",
        "a. 变化值：本期数据对比上期数据的变化",
        "b. 变化率：本期数据对比上期数据的变化比率",
        "c. 对比值：对比的上期数据值",
        "5. 高级计算-TopN：分为TopN和BottomN，需要确定N的数值。TopN计算只作用在一个指标上。",
        "a. TopN：计算按当前排序规则的前N项数据",
        "b. BottomN：计算按当前排序规则的后N项数据",
        "6. 高级计算-占比：计算指标在对应维度分类中数据占比，占比只作用在一个指标上。优先使用已存在的维度占比字段，无占比字段时使用高级计算占比",
        "7. 高级计算-日均：需确定日期字段，输出格式 { '字段名称': '指标字段名称',  '日均': '日期字段' }",
        "8. 排序规则：指标字段排序规则包括升序、降序、不排序。",
        "## 维度规则生成",
        "1基于**维度配置**中的维度项和`表规则`中维度相关部分，从候选字段中找到最匹配的字段（可以匹配多个字段；请参考业务知识、字段元信息），如果是业务知识中的维度集合需要同时使用这些字段作为维度字段，如果是日期字段需确定日期粒度 ",
        "## 筛选条件规则的配置知识",
        "以下是提供给你的筛选条件规则的配置知识，在后续规则配置流程中需要参照这份知识",
        "**字段数据类型：日期、日期时间、字符串、整数、浮点数，对应的不同的匹配类型**",
        "### '字符串'类型字段",
        "'字符串'类型字段条件匹配类型有`精确匹配`和`模糊匹配`：",
        "精确匹配：即完全匹配条件值，当且仅当'等于'、'='或'为'的表达对应精确匹配",
        "模糊匹配：即模糊匹配条件值，当且仅当'有关'、'关于'、'相关'、'类似'、'包含'、'含'，'系列'、'涉及'等表达对应模糊匹配方式，默认'不区分大小写和空格'。",
        "### '日期'、'日期时间'类型字段",
        "字段类型为'日期'、'日期时间'的条件匹配类型有`相对时间`和`绝对时间`。",
        "相对时间：相对于某一个时间锚点的时间周期描述：",
        "- 单天类型：枚举值有 今天、昨天、前天、最新数据日期",
        "- 近n天类型：标准形式为'近X天'，其中X为正整数，类似最近 x 天/前 x 天均归一为 '近x 天'，近三天 -> 近3天",
        "- 周期类型：枚举值有 本周、上周、本月、上月、本季度、上季度、本双月、上双月",
        "- 当用户query中未提到时间相关信息，则默认选择相对时间中单天类型：昨天。",
        "绝对时间：一个具体的时间起止范围，起始时间和截止时间至少包含一个。日期时间描述在处理时需要转换为标准格式,没有指定年份时分两类：1、月份已发生的默认选择当前时间所在年；2、月份未发生的默认选择当前时间前一年。如：今天是2025年4月7日，用户query问11月1至11月20日数据，则查询2024年11月1至11月20日；用户query问1月1至3月20日数据，则查询2025年1月1至3月20日。",
        "- '24年10月-11月': ['2024-10-01', '2024-11-30']",
        "- '5月至10月': ['2024-05-01', '2024-10-31']",
        "- '2024年第三季度': ['2024-07-01', '2024-09-30']",
        "- '2024年10-1至今': ['2024-10-01','2025-08-24']",
        "- 'x天以前': [null, '2024-11-20']",
        "### '整数'、'浮点数'类型字段",
        "字段类型为整数、浮点数的字段条件匹配类型包括`等于`、`不等于`、`大于`、`大于等于`、`小于`、`小于等于`、`在区间`、`不为空`，其中在区间的条件值需要2个。",
        "以下是你所生成的历史DSL配置：\n",
    ]
    for ex in examples:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines.append(f"用户query：{_query}\nDSL配置：{_dsl}\n")

    prompt_lines += [
        "\n\n",
        "以下是当前你需要改写的新用户query：\n",
        f"用户query：{query}\n",
        "已知DSL配置和query以及表数据对应，请你根据生成的历史DSL配置中的映射关系为当前用户query生成真实可用的DSL配置，请勿生成历史DSL配置中不存在的配置项。你生成的配置格式应当为与历史DSL配置完全一致的JSON格式。回答除了配置格式不附加任何额外信息。"
    ]
    return "\n".join(prompt_lines)


def build_prompt_v_0_0_5(query: str, examples: List[Dict[str, any]], **args) -> str:
    prompt_lines = [
        "在此前阶段，你基于用户的query生成了若干用于数据查询的DSL配置，现在，你需要根据当前用户的query以及相似query对应的DSL配置改写出当前query对应的DSL配置。",
        "以下是你所生成的历史DSL配置：\n",
    ]

    k = args["k"]
    prompt_lines.append(
        f"以下例子特别关注配置格式，如‘查询交通出行行业2024年10月份的广告流水，分各赛道和营销目的细分’中关注‘查询行业份的广告流水分各赛道和营销目的细分’：")
    for ex in examples[:k]:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines.append(f"用户query：{_query}\nDSL配置：{_dsl}\n")

    prompt_lines.append(
        f"以下例子特别关注关键词，如‘查询交通出行行业2024年10月份的广告流水，分各赛道和营销目的细分’中关注‘交通出行’")
    for ex in examples[k:]:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines.append(f"用户query：{_query}\nDSL配置：{_dsl}\n")

    prompt_lines += [
        "\n\n",
        "以下是当前你需要改写的新用户query：\n",
        f"用户query：{query}\n",
        "已知DSL配置和query以及表数据对应，请你根据生成的历史DSL配置中的映射关系为当前用户query生成真实可用的DSL配置，请勿生成历史DSL配置中不存在的配置项。你生成的配置格式应当为与历史DSL配置完全一致的JSON格式。回答除了配置格式不附加任何额外信息。"
    ]
    return "\n".join(prompt_lines)


def build_prompt_v_0_0_6(query: str, examples: List[Dict[str, any]], **args) -> str:
    prompt_lines = [
        "在此前阶段，你基于用户的query生成了若干用于数据查询的DSL配置，现在，你需要根据当前用户的query以及相似query对应的DSL配置改写出当前query对应的DSL配置。",
        "此外这个环节会提供表规则需要基于`表规则`补充指标规则:",
        "## 指标规则的配置知识",
        "以下是提供给你的指标规则的配置知识，在后续规则配置流程中需要参照这份知识",


        "1. 字段数据类型：日期、日期时间、字符串、整数、浮点数、布尔值。",
        "2. 字段角色：维度、指标。",
        "维度包含定量值（例如名称、日期或地理数据）。可以使用维度进行分类、分段以及揭示数据中的详细信息。维度影响视图中的详细级别。",
        "指标包含可以测量的数字定量值，有确定的聚合状态。维度字段也可以应用聚合方式（计数、去重计数、最大值、最小值）形成指标，例如用户数可以是 用户名的去重计数。",
        "3. 指标聚合状态：已聚合、未聚合。",
        "已聚合：指标字段已经聚合，不需要再次聚合。",
        "未聚合：指标字段未聚合，需要确定聚合方式。聚合方式是 求和、计数、去重计数、平均值、最大值、最小值 中的一种。不同数据类型的字段可应用的聚合方式不同，具体是：",
        "a. 整数、浮点数：求和、计数、去重计数、平均值、最大值、最小值",
        "b. 字符串、日期、日期时间：计数、去重计数、最大值、最小值",
        "4. 高级计算-同环比：同环比计算不同时间区间的数据对比情况，需要确定同环比类型、对比结果类型及使用的时间维度。",
        "同环比类型从以下几种中选择一个：",
        "a. 环比-上期：本期数据对比上期数据，本期和上期是相邻的时间周期，例如今日和昨日数据、本周和上周数据、近3天和近6至4天数据",
        "b. 环比-上上期：本期数据对比上上期数据，例如本周周二对比上上周周二数据",
        "c. 周同比：本周对比上周同期数据，例如本周周二对比上周周二数据",
        "d. 月同比：本期数据对比上月同期数据，例如本月3日对比上月3日数据、本月10-20日数据对比上月10-20日数据",
        "e. 年同比：本期数据对比去年同期数据，例如本年9月3日对比去年9月3日数据、本年10月数据对比去年10月数据",
        "对比结果类型从以下几种中选择一个：",
        "a. 变化值：本期数据对比上期数据的变化",
        "b. 变化率：本期数据对比上期数据的变化比率",
        "c. 对比值：对比的上期数据值",
        "5. 高级计算-TopN：分为TopN和BottomN，需要确定N的数值。TopN计算只作用在一个指标上。",
        "a. TopN：计算按当前排序规则的前N项数据",
        "b. BottomN：计算按当前排序规则的后N项数据",
        "6. 高级计算-占比：计算指标在对应维度分类中数据占比，占比只作用在一个指标上。优先使用已存在的维度占比字段，无占比字段时使用高级计算占比",
        "7. 高级计算-日均：需确定日期字段，输出格式 { '字段名称': '指标字段名称',  '日均': '日期字段' }",
        "8. 排序规则：指标字段排序规则包括升序、降序、不排序。",
        "## 维度规则生成",
        "1基于**维度配置**中的维度项和`表规则`中维度相关部分，从候选字段中找到最匹配的字段（可以匹配多个字段；请参考业务知识、字段元信息），如果是业务知识中的维度集合需要同时使用这些字段作为维度字段，如果是日期字段需确定日期粒度 ",
        "## 筛选条件规则的配置知识",
        "以下是提供给你的筛选条件规则的配置知识，在后续规则配置流程中需要参照这份知识",
        "**字段数据类型：日期、日期时间、字符串、整数、浮点数，对应的不同的匹配类型**",
        "### '字符串'类型字段",
        "'字符串'类型字段条件匹配类型有`精确匹配`和`模糊匹配`：",
        "精确匹配：即完全匹配条件值，当且仅当'等于'、'='或'为'的表达对应精确匹配",
        "模糊匹配：即模糊匹配条件值，当且仅当'有关'、'关于'、'相关'、'类似'、'包含'、'含'，'系列'、'涉及'等表达对应模糊匹配方式，默认'不区分大小写和空格'。",
        "### '日期'、'日期时间'类型字段",
        "字段类型为'日期'、'日期时间'的条件匹配类型有`相对时间`和`绝对时间`。",
        "相对时间：相对于某一个时间锚点的时间周期描述：",
        "- 单天类型：枚举值有 今天、昨天、前天、最新数据日期",
        "- 近n天类型：标准形式为'近X天'，其中X为正整数，类似最近 x 天/前 x 天均归一为 '近x 天'，近三天 -> 近3天",
        "- 周期类型：枚举值有 本周、上周、本月、上月、本季度、上季度、本双月、上双月",
        "- 当用户query中未提到时间相关信息，则默认选择相对时间中单天类型：昨天。",
        "绝对时间：一个具体的时间起止范围，起始时间和截止时间至少包含一个。日期时间描述在处理时需要转换为标准格式,没有指定年份时分两类：1、月份已发生的默认选择当前时间所在年；2、月份未发生的默认选择当前时间前一年。如：今天是2025年4月7日，用户query问11月1至11月20日数据，则查询2024年11月1至11月20日；用户query问1月1至3月20日数据，则查询2025年1月1至3月20日。",
        "- '24年10月-11月': ['2024-10-01', '2024-11-30']",
        "- '5月至10月': ['2024-05-01', '2024-10-31']",
        "- '2024年第三季度': ['2024-07-01', '2024-09-30']",
        "- '2024年10-1至今': ['2024-10-01','2025-08-24']",
        "- 'x天以前': [null, '2024-11-20']",
        "### '整数'、'浮点数'类型字段",
        "字段类型为整数、浮点数的字段条件匹配类型包括`等于`、`不等于`、`大于`、`大于等于`、`小于`、`小于等于`、`在区间`、`不为空`，其中在区间的条件值需要2个。",
        "以下是你所生成的历史DSL配置：\n",
    ]
    k = args["k"]
    prompt_lines.append(
        f"以下例子特别关注配置格式，如‘查询交通出行行业2024年10月份的广告流水，分各赛道和营销目的细分’中关注‘查询行业份的广告流水分各赛道和营销目的细分’：")
    for ex in examples[:k]:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines.append(f"用户query：{_query}\nDSL配置：{_dsl}\n")

    prompt_lines.append(
        f"以下例子特别关注关键词，如‘查询交通出行行业2024年10月份的广告流水，分各赛道和营销目的细分’中关注‘交通出行’")
    for ex in examples[k:]:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines.append(f"用户query：{_query}\nDSL配置：{_dsl}\n")

    prompt_lines += [
        "\n\n",
        "以下是当前你需要改写的新用户query：\n",
        f"用户query：{query}\n",
        "已知DSL配置和query以及表数据对应，请你根据生成的历史DSL配置中的映射关系为当前用户query生成真实可用的DSL配置，请勿生成历史DSL配置中不存在的配置项。你生成的配置格式应当为与历史DSL配置完全一致的JSON格式。回答除了配置格式不附加任何额外信息。"
    ]
    return "\n".join(prompt_lines)


def build_prompt_v_0_0_7(query: str, examples: List[Dict[str, any]], **args) -> str:
    prompt_lines = [
        "在此前阶段，你基于用户的query生成了若干用于数据查询的DSL配置，现在，你需要根据当前用户的query以及相似query对应的DSL配置改写出当前query对应的DSL配置。",
        "此外这个环节会提供表规则需要基于`表规则`补充指标规则:",
        "## 指标规则的配置知识",
        "以下是提供给你的指标规则的配置知识，在后续规则配置流程中需要参照这份知识",

        "1. 字段数据类型：日期、日期时间、字符串、整数、浮点数、布尔值。",
        "2. 字段角色：维度、指标。",
        "维度包含定量值（例如名称、日期或地理数据）。可以使用维度进行分类、分段以及揭示数据中的详细信息。维度影响视图中的详细级别。",
        "指标包含可以测量的数字定量值，有确定的聚合状态。维度字段也可以应用聚合方式（计数、去重计数、最大值、最小值）形成指标，例如用户数可以是 用户名的去重计数。",
        "3. 指标聚合状态：已聚合、未聚合。",
        "已聚合：指标字段已经聚合，不需要再次聚合。",
        "未聚合：指标字段未聚合，需要确定聚合方式。聚合方式是 求和、计数、去重计数、平均值、最大值、最小值 中的一种。不同数据类型的字段可应用的聚合方式不同，具体是：",
        "a. 整数、浮点数：求和、计数、去重计数、平均值、最大值、最小值",
        "b. 字符串、日期、日期时间：计数、去重计数、最大值、最小值",
        "4. 高级计算-同环比：同环比计算不同时间区间的数据对比情况，需要确定同环比类型、对比结果类型及使用的时间维度。",
        "同环比类型从以下几种中选择一个：",
        "a. 环比-上期：本期数据对比上期数据，本期和上期是相邻的时间周期，例如今日和昨日数据、本周和上周数据、近3天和近6至4天数据",
        "b. 环比-上上期：本期数据对比上上期数据，例如本周周二对比上上周周二数据",
        " c. 周同比：本周对比上周同期数据，例如本周周二对比上周周二数据",
        "d. 月同比：本期数据对比上月同期数据，例如本月3日对比上月3日数据、本月10-20日数据对比上月10-20日数据",
        "e. 年同比：本期数据对比去年同期数据，例如本年9月3日对比去年9月3日数据、本年10月数据对比去年10月数据",
        "对比结果类型从以下几种中选择一个：",
        "a. 变化值：本期数据对比上期数据的变化",
        "b. 变化率：本期数据对比上期数据的变化比率",
        "c. 对比值：对比的上期数据值",
        "5. 高级计算-TopN：分为TopN和BottomN，需要确定N的数值。TopN计算只作用在一个指标上。",
        "a. TopN：计算按当前排序规则的前N项数据",
        "b. BottomN：计算按当前排序规则的后N项数据",
        "6. 高级计算-占比：计算指标在对应维度分类中数据占比，占比只作用在一个指标上。优先使用已存在的维度占比字段，无占比字段时使用高级计算占比",
        "7. 高级计算-日均：需确定日期字段，输出格式 { '字段名称': '指标字段名称',  '日均': '日期字段' }",
        "8. 排序规则：指标字段排序规则包括升序、降序、不排序。",
        "## 维度规则生成",
        "1基于**维度配置**中的维度项和`表规则`中维度相关部分，从候选字段中找到最匹配的字段（可以匹配多个字段；请参考业务知识、字段元信息），如果是业务知识中的维度集合需要同时使用这些字段作为维度字段，如果是日期字段需确定日期粒度 ",
        "## 筛选条件规则的配置知识",
        "以下是提供给你的筛选条件规则的配置知识，在后续规则配置流程中需要参照这份知识",
        "**字段数据类型：日期、日期时间、字符串、整数、浮点数，对应的不同的匹配类型**",
        "### '字符串'类型字段",
        "'字符串'类型字段条件匹配类型有`精确匹配`和`模糊匹配`：",
        "精确匹配：即完全匹配条件值，当且仅当'等于'、'='或'为'的表达对应精确匹配",
        "模糊匹配：即模糊匹配条件值，当且仅当'有关'、'关于'、'相关'、'类似'、'包含'、'含'，'系列'、'涉及'等表达对应模糊匹配方式，默认'不区分大小写和空格'。",
        "### '日期'、'日期时间'类型字段",
        "字段类型为'日期'、'日期时间'的条件匹配类型有`相对时间`和`绝对时间`。",
        "相对时间：相对于某一个时间锚点的时间周期描述：",
        "- 单天类型：枚举值有 今天、昨天、前天、最新数据日期",
        "- 近n天类型：标准形式为'近X天'，其中X为正整数，类似最近 x 天/前 x 天均归一为 '近x 天'，近三天 -> 近3天",
        "- 周期类型：枚举值有 本周、上周、本月、上月、本季度、上季度、本双月、上双月",
        "- 当用户query中未提到时间相关信息，则默认选择相对时间中单天类型：昨天。",
        "绝对时间：一个具体的时间起止范围，起始时间和截止时间至少包含一个。日期时间描述在处理时需要转换为标准格式,没有指定年份时分两类：1、月份已发生的默认选择当前时间所在年；2、月份未发生的默认选择当前时间前一年。如：今天是2025年4月7日，用户query问11月1至11月20日数据，则查询2024年11月1至11月20日；用户query问1月1至3月20日数据，则查询2025年1月1至3月20日。",
        "- '24年10月-11月': ['2024-10-01', '2024-11-30']",
        "- '5月至10月': ['2024-05-01', '2024-10-31']",
        "- '2024年第三季度': ['2024-07-01', '2024-09-30']",
        "- '2024年10-1至今': ['2024-10-01','2025-08-24']",
        "- 'x天以前': [null, '2024-11-20']",
        "### '整数'、'浮点数'类型字段",
        "字段类型为整数、浮点数的字段条件匹配类型包括`等于`、`不等于`、`大于`、`大于等于`、`小于`、`小于等于`、`在区间`、`不为空`，其中在区间的条件值需要2个。\n\n",
        "以下是你以前依照生成的历史DSL配置：\n",
    ]
    for ex in examples:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines.append(f"用户query：{_query}\nDSL配置：{_dsl}\n")

    prompt_lines += [
        "\n\n",
        "以下是当前你需要改写的新用户query：\n",
        f"用户query：{query}\n\n",
        "以下是用户query筛选条件可能涉及的维度维值：\n"
    ]

    dimvals = args["dimvals"]
    for dim, val in dimvals:
        prompt_lines.append(f"维度：{dim}, 维值：{val}")

    prompt_lines += [
        "已知DSL配置和query以及表数据对应，请你根据生成的历史DSL配置中的映射关系以及可能涉及的维度维值为当前用户query生成真实可用的DSL配置，请勿生成历史DSL配置中不存在的配置项和不存在在维度维值中的筛选条件。",
        "你生成的配置格式应当为与历史DSL配置完全一致的JSON格式。回答除了配置格式不附加任何额外信息。"
    ]
    return "\n".join(prompt_lines)


def build_prompt_v_0_0_8(query: str, examples: List[Dict[str, any]], **args) -> str:
    prompt_lines = [
        "你现在需要按照指令，基于用户的问题生成企业场景下用于数据查询的维度、指标、筛选条件配置，这三者概念上大致对应SQL查询预计中的SELECT、WHERE、聚合函数形成的新列。",
        "以下是当前的用户问题：",
        f"{query}\n",
        "以及该问题的筛选条件可能涉及在实际数据存储中的字段和列值："
    ]
    if hasattr(args, "dimvals"):
        dimvals = args["dimvals"]
        for dim, val in dimvals:
            prompt_lines.append(f"字段：{dim}, 值：{val}")
    prompt_lines += [
        "\n\n",
        "同时，为了确保生成配置的可靠性，你所生成配置中的维度、指标、筛选条件需要符合以下规则：\n",
        "## 维度配置规则",
        "1. 基于**维度配置**中的维度项和`表规则`中维度相关部分，从候选字段中找到最匹配的字段（可以匹配多个字段；请参考业务知识、字段元信息），如果是业务知识中的维度集合需要同时使用这些字段作为维度字段，如果是日期字段需确定日期粒度 ",

        "## 指标配置规则",
        "1. 字段数据类型的可选值：日期、日期时间、字符串、整数、浮点数、布尔值。",
        "2. 字段角色的可选值：维度、指标。",
        "\t + 维度包含定量值（例如名称、日期或地理数据）。可以使用维度进行分类、分段以及揭示数据中的详细信息。维度影响视图中的详细级别。",
        "\t + 指标包含可以测量的数字定量值，有确定的聚合状态。维度字段也可以应用聚合方式（计数、去重计数、最大值、最小值）形成指标，例如用户数可以是 用户名的去重计数。",
        "3. 指标聚合状态的可选值：已聚合、未聚合。",
        "\t + 已聚合：指标字段已经聚合，不需要再次聚合。",
        "\t + 未聚合：指标字段未聚合，需要确定聚合方式。聚合方式是 求和、计数、去重计数、平均值、最大值、最小值 中的一种。不同数据类型的字段可应用的聚合方式不同，具体是：",
        "4. 整数、浮点数聚合方式的可选值：求和、计数、去重计数、平均值、最大值、最小值",
        "5. 字符串、日期、日期时间聚合方式的可选值：计数、去重计数、最大值、最小值",
        "6. 高级计算-同环比：同环比计算不同时间区间的数据对比情况，需要确定同环比类型、对比结果类型及使用的时间维度。"
        "\t 同环比类型的可选值如下（最多选一个）:",
        "\t\t + 环比-上期：本期数据对比上期数据，本期和上期是相邻的时间周期，例如今日和昨日数据、本周和上周数据、近3天和近6至4天数据",
        "\t\t + 环比-上上期：本期数据对比上上期数据，例如本周周二对比上上周周二数据",
        "\t\t + 周同比：本周对比上周同期数据，例如本周周二对比上周周二数据",
        "\t\t + 月同比：本期数据对比上月同期数据，例如本月3日对比上月3日数据、本月10-20日数据对比上月10-20日数据",
        "\t\t + 年同比：本期数据对比去年同期数据，例如本年9月3日对比去年9月3日数据、本年10月数据对比去年10月数据",
        "\t 对比结果类型的可选值如下（最多选一个）：",
        "\t + 变化值：本期数据对比上期数据的变化",
        "\t + 变化率：本期数据对比上期数据的变化比率",
        "\t + 对比值：对比的上期数据值",
        "7. 高级计算-TopN：分为TopN和BottomN，需要确定N的数值。TopN计算只作用在一个指标上。",
        "\t + TopN：计算按当前排序规则的前N项数据",
        "\t + BottomN：计算按当前排序规则的后N项数据",
        "8. 高级计算-占比：计算指标在对应维度分类中数据占比，占比只作用在一个指标上。优先使用已存在的维度占比字段，无占比字段时使用高级计算占比",
        "9. 高级计算-日均：需确定日期字段，输出格式 { '字段名称': '指标字段名称',  '日均': '日期字段' }",
        "10. 排序规则：指标字段排序规则包括升序、降序、不排序。",

        "## 筛选条件配置规则",
        "筛选条件可以理解为SQL中的where语句，即其作用为对查询数据的字段进行值上的限定，由于业务场景的需要，你需要根据筛选条件字段的数据类型来对应不同的匹配类型：",
        "1. '字符串'类型字段条件匹配类型有`精确匹配`和`模糊匹配`：",
        "\t + 精确匹配：即完全匹配条件值，当且仅当'等于'、'='或'为'的表达对应精确匹配",
        "\t + 模糊匹配：即模糊匹配条件值，当且仅当'有关'、'关于'、'相关'、'类似'、'包含'、'含'，'系列'、'涉及'等表达对应模糊匹配方式，默认'不区分大小写和空格'。",
        "2. '日期'、'日期时间'类型字段的条件匹配类型有`相对时间`和`绝对时间`。",
        "\t + 相对时间：相对于某一个时间锚点的时间周期描述：",
        "\t\t - 单天类型：枚举值有 今天、昨天、前天、最新数据日期",
        "\t\t - 近n天类型：标准形式为'近X天'，其中X为正整数，类似最近 x 天/前 x 天均归一为 '近x 天'，近三天 -> 近3天",
        "\t\t - 周期类型：枚举值有 本周、上周、本月、上月、本季度、上季度、本双月、上双月",
        "\t\t - 当用户query中未提到时间相关信息，则默认选择相对时间中单天类型：昨天。",
        "\t + 绝对时间：一个具体的时间起止范围，起始时间和截止时间至少包含一个。日期时间描述在处理时需要转换为标准格式,没有指定年份时分两类：1、月份已发生的默认选择当前时间所在年；2、月份未发生的默认选择当前时间前一年。如：今天是2025年4月7日，用户query问11月1至11月20日数据，则查询2024年11月1至11月20日；用户query问1月1至3月20日数据，则查询2025年1月1至3月20日。",
        "\t\t - '24年10月-11月': ['2024-10-01', '2024-11-30']",
        "\t\t - '5月至10月': ['2024-05-01', '2024-10-31']",
        "\t\t - '2024年第三季度': ['2024-07-01', '2024-09-30']",
        "\t\t - '2024年10-1至今': ['2024-10-01','2025-08-24']",
        "\t\t - 'x天以前': [null, '2024-11-20']",
        "3.'整数'、'浮点数'类型字段的条件匹配类型包括`等于`、`不等于`、`大于`、`大于等于`、`小于`、`小于等于`、`在区间`、`不为空`，其中在区间的条件值需要2个。\n\n",

        "现在，请你根据上面提供的所有数据和规则为用户为题生成查询配置，作为参考，以下是一些<用户问题, 查询配置>的例子：\n",
    ]
    for ex in examples:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines += [
            "## 用户问题",
            f"{_query}",
            "## 对应查询配置",
            f"{_dsl}\n"
        ]

    prompt_lines += [
        "请你参考上述例子的映射关系结合当前用户问题、‘筛选条件可能涉及的字段和值’，从例子的配置中改写出当前问题的查询配置，请勿生成例子中不存在的配置项和没有给出的字段和值。",
        # "请你参考上述例子的映射关系结合当前用户问题、筛选条件可能涉及的字段和值开始生成查询配置。过程中请注意以下几点：",
        "1. 上面提供的'筛选条件可能涉及的字段和值'只能用于配置中筛选条件的生成。",
        "2. '筛选条件可能涉及的字段和值'可能存在不精确或于当前用户问题无关的情况，请你注意甄别。",
        "3. 你生成的配置格式应当为与例子完全一致的JSON格式，回答除了生成的配置外不要附加任何额外信息。"
    ]
    return "\n".join(prompt_lines)


def build_prompt_v_0_0_9(query: str, examples: List[Dict[str, any]], **args) -> str:

    prompt = """# 角色
你是一个数据分析助手，负责根据用户查询生成数据查询的DSL配置。
# 工作流程
1、根据当前用户的query以及相似query、相似query的配置，按照生成配置的规则去生成准确且可执行的DSL配置。
请严格遵循以下规则：

## 指标规则的配置知识
以下是提供给你的指标规则的配置知识，在后续规则配置流程中需要参照这份知识
1. 字段数据类型：日期、日期时间、字符串、整数、浮点数、布尔值。
2. 字段角色：维度、指标。
维度包含定量值（例如名称、日期或地理数据）。可以使用维度进行分类、分段以及揭示数据中的详细信息。维度影响视图中的详细级别。
指标包含可以测量的数字定量值，有确定的聚合状态。维度字段也可以应用聚合方式（计数、去重计数、最大值、最小值）形成指标，例如用户数可以是 用户名的去重计数。
3. 指标聚合状态：已聚合、未聚合。
已聚合：指标字段已经聚合，不需要再次聚合。
未聚合：指标字段未聚合，需要确定聚合方式。聚合方式是 求和、计数、去重计数、平均值、最大值、最小值 中的一种。不同数据类型的字段可应用的聚合方式不同，具体是：
a. 整数、浮点数：求和、计数、去重计数、平均值、最大值、最小值
b. 字符串、日期、日期时间：计数、去重计数、最大值、最小值
4. 高级计算-同环比：同环比计算不同时间区间的数据对比情况，需要确定同环比类型、对比结果类型及使用的时间维度。
同环比类型从以下几种中选择一个：
a. 环比-上期：本期数据对比上期数据，本期和上期是相邻的时间周期，例如今日和昨日数据、本周和上周数据、近3天和近6至4天数据
b. 环比-上上期：本期数据对比上上期数据，例如本周周二对比上上周周二数据
c. 周同比：本周对比上周同期数据，例如本周周二对比上周周二数据
d. 月同比：本期数据对比上月同期数据，例如本月3日对比上月3日数据、本月10-20日数据对比上月10-20日数据
e. 年同比：本期数据对比去年同期数据，例如本年9月3日对比去年9月3日数据、本年10月数据对比去年10月数据
对比结果类型从以下几种中选择一个：
a. 变化值：本期数据对比上期数据的变化
b. 变化率：本期数据对比上期数据的变化比率
c. 对比值：对比的上期数据值
5. 高级计算-TopN：分为TopN和BottomN，需要确定N的数值。TopN计算只作用在一个指标上。
a. TopN：计算按当前排序规则的前N项数据
b. BottomN：计算按当前排序规则的后N项数据
6. 高级计算-占比：计算指标在对应维度分类中数据占比，占比只作用在一个指标上。优先使用已存在的维度占比字段，无占比字段时使用高级计算占比
7. 高级计算-日均：需确定日期字段，输出格式 { '字段名称': '指标字段名称',  '日均': '日期字段' }
8. 排序规则：指标字段排序规则包括升序、降序、不排序。
## 维度规则生成
1基于**维度配置**中的维度项和中维度相关部分，从候选字段中找到最匹配的字段（可以匹配多个字段；请参考业务知识、字段元信息），如果是业务知识中的维度集合需要同时使用这些字段作为维度字段，如果是日期字段需确定日期粒度
## 筛选条件规则的配置知识
以下是提供给你的筛选条件规则的配置知识，在后续规则配置流程中需要参照这份知识
**字段数据类型：日期、日期时间、字符串、整数、浮点数，对应的不同的匹配类型**
### '字符串'类型字段
'字符串'类型字段条件匹配类型有和：
精确匹配：即完全匹配条件值，当且仅当'等于'、'='或'为'的表达对应精确匹配
模糊匹配：即模糊匹配条件值，当且仅当'有关'、'关于'、'相关'、'类似'、'包含'、'含'，'系列'、'涉及'等表达对应模糊匹配方式，默认'不区分大小写和空格'。
### '日期'、'日期时间'类型字段
字段类型为'日期'、'日期时间'的条件匹配类型有和。
相对时间：相对于某一个时间锚点的时间周期描述：
- 单天类型：枚举值有 今天、昨天、前天、最新数据日期
- 近n天类型：标准形式为'近X天'，其中X为正整数，类似最近 x 天/前 x 天均归一为 '近x 天'，近三天 -> 近3天
- 周期类型：枚举值有 本周、上周、本月、上月、本季度、上季度、本双月、上双月
- 当用户query中未提到时间相关信息，则默认选择相对时间中单天类型：昨天。
绝对时间：一个具体的时间起止范围，起始时间和截止时间至少包含一个。日期时间描述在处理时需要转换为标准格式,没有指定年份时分两类：1、月份已发生的默认选择当前时间所在年；2、月份未发生的默认选择当前时间前一年。如：今天是2025年4月7日，用户query问11月1至11月20日数据，则查询2024年11月1至11月20日；用户query问1月1至3月20日数据，则查询2025年1月1至3月20日。
- '24年10月-11月': ['2024-10-01', '2024-11-30']
- '5月至10月': ['2024-05-01', '2024-10-31']
- '2024年第三季度': ['2024-07-01', '2024-09-30']
- '2024年10-1至今': ['2024-10-01','2025-08-24']
- 'x天以前': [null, '2024-11-20']
### '整数'、'浮点数'类型字段
字段类型为整数、浮点数的字段条件匹配类型包括`等于`、`不等于`、`大于`、`大于等于`、`小于`、`小于等于`、`在区间`、`不为空`，其中在区间的条件值需要2个。


"""
    prompt_lines = [
        "** 用户新query信息 **",
        f"用户query：{query}",
        "",
        "用户query筛选条件可能涉及的维度维值："
    ]
    if hasattr(args, "dimvals"):
        dimvals = args["dimvals"]
        for dim, val in dimvals:
            prompt_lines.append(f"维度: {dim} 维值: {val}")

    prompt_lines += [
        "",
        ""
        "** 相似查询示例 **",
    ]

    for ex in examples:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines += [
            f"- 用户查询: {_query}",
            f"- DSL配置: {_dsl} "
        ]

    """
    ** 候选字段：**
    [
        {%- for field in session.TEMPLATE_RECALL_EXEC_CODE.field_info %}
        {"字段名称": "{{ field.字段名称 }}", {%- if field.字段别名 != 'null' %} "字段别名": "{{ field.字段别名 }}",  {% endif %} "数据类型": "{{ field.数据类型 }}", "角色": "{{ field.角色 }}", {%- if field.是否已聚合 is defined %} "是否已聚合": "{{ field.是否已聚合 }}",  {% endif %}{%- if field.是否分区 is defined %} "是否分区": "{{ field.是否分区 }}",  {% endif %}{%- if field.业务日期 is defined %} "业务日期": "{{ field.业务日期 }}", {% endif %}{%- if field.维值 is defined %} "维值": {{ field.维值 }} {% endif %}}{%- if not loop.last %},{% endif %}
        {%- endfor %}
    ]
    """

    prompt_lines += [
        "",
        "",
        "** 输出规范 **",
        "1. 配置依据：基于历史DSL配置的字段映射关系和提供的维度值生成配置",
        "2. 内容限制：禁止使用历史配置中未出现过的配置项或维度值中不存在的筛选条件",
        "3. 格式要求：输出必须与历史DSL配置保持完全一致的JSON格式",
        "4. 输出纯净：除JSON配置外，不包含任何额外文本、解释或注释"
    ]

    return prompt + "\n".join(prompt_lines)


def build_prompt_v_0_0_9_b(query: str, examples: List[Dict[str, any]], **args) -> str:

    prompt = """# 角色
你是一个数据分析助手，负责根据用户查询生成数据查询的DSL配置。
# 工作流程
1、根据当前用户的query以及相似query、相似query的配置，按照生成配置的规则去生成准确且可执行的DSL配置。
"""
    prompt_lines = [
        "** 用户新query信息 **",
        f"用户query：{query}",
        "",
        "用户query筛选条件可能涉及的维度维值："
    ]
    if hasattr(args, "dimvals"):
        dimvals = args["dimvals"]
        for dim, val in dimvals:
            prompt_lines.append(f"维度: {dim} 维值: {val}")

    prompt_lines += [
        "",
        ""
        "** 相似查询示例 **",
    ]

    for ex in examples:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        prompt_lines += [
            f"- 用户查询: {_query}",
            f"- DSL配置: {_dsl} "
        ]

    """
    ** 候选字段：**
    [
        {%- for field in session.TEMPLATE_RECALL_EXEC_CODE.field_info %}
        {"字段名称": "{{ field.字段名称 }}", {%- if field.字段别名 != 'null' %} "字段别名": "{{ field.字段别名 }}",  {% endif %} "数据类型": "{{ field.数据类型 }}", "角色": "{{ field.角色 }}", {%- if field.是否已聚合 is defined %} "是否已聚合": "{{ field.是否已聚合 }}",  {% endif %}{%- if field.是否分区 is defined %} "是否分区": "{{ field.是否分区 }}",  {% endif %}{%- if field.业务日期 is defined %} "业务日期": "{{ field.业务日期 }}", {% endif %}{%- if field.维值 is defined %} "维值": {{ field.维值 }} {% endif %}}{%- if not loop.last %},{% endif %}
        {%- endfor %}
    ]
    """

    prompt_lines += [
        "",
        "",
        "** 输出规范 **",
        "1. 配置依据：基于历史DSL配置的字段映射关系和提供的维度值生成配置",
        "2. 内容限制：禁止使用历史配置中未出现过的配置项或维度值中不存在的筛选条件",
        "3. 格式要求：输出必须与历史DSL配置保持完全一致的JSON格式",
        "4. 输出纯净：除JSON配置外，不包含任何额外文本、解释或注释"
    ]

    return prompt + "\n".join(prompt_lines)


def build_prompt_v_spider_1(query: str, examples: List[Dict[str, any]], **args) -> str:
    system_prompt = """# 角色:你是一个数据分析助手，负责根据用户查询生成数据查询的DSL配置。
### 输入格式
[question]:<question_value>
[example question and corresponding DSL]:
{
    "question": "<question_text>",
    "SQL": "<SQL_text>",
    "db_id": "<db_id_text>",
    "table_name": "<table_name_value>",
    "id": "<id_value>",
    "config": {
        "dimension": [
            {
                "column": "<column_value>"
            }
        ],
        "measure": [
            {
                "column": "<column_value>",
                "aggregate_function": "<aggregate_function_value>"
            }
        ],
        "filter": [
            {
                "column": "<column_value>",
                "match_type": "<match_type_value>",
                "condition": "<condition_value>"
            },
            {
                "column": "<column_value2>",
                "match_type": "<match_type_value2>",
                "condition": "<condition_value2>"
            }
        ],
    }
}
[example question and corresponding DSL]:
{
    "question": "<question_text>",
    "SQL": "<SQL_text>",
    "db_id": "<db_id_text>",
    "table_name": "<table_name_value>",
    "id": "<id_value>",
    "config": {
        "dimension": [
            {
                "column": "<column_value>"
            }
        ],
        "measure": [
            {
                "column": "<column_value>",
                "aggregate_function": "<aggregate_function_value>"
            }
        ],
        "filter": [
            {
                "column": "<column_value>",
                "match_type": "<match_type_value>",
                "condition": "<condition_value>"
            },
            {
                "column": "<column_value2>",
                "match_type": "<match_type_value2>",
                "condition": "<condition_value2>"
            }
        ],
    }
}

# 工作流程
## 步骤一：理解用户输入的question

## 步骤二：输入中包含多个json格式的example question以及对应的DSL配置信息，理解这些example question和当前question的细微语义差别

## 步骤三：明确example question中与当前question语义结构差异（除去filter以外的查询部分）最小的question，并对其DSL进行修改以得到当前question的DSL

### DSL相关定义和配置规则

DSL由[measure]、[dimension]、[filter]三个关键要素组成

#### measure
1. measure定义：指标是用户问题中希望量化和计算的目标，它不再是一个简单的预定义字段，而是需要通过对一个或多个字段应用聚合函数（如 COUNT, SUM, AVG）或进行算术运算来动态生成
2. measure提取规则：明确[measure]在SQL query中对应的[column]以及[aggregate_function]，aggregate function为[SUM]、[COUNT]、[DISTINCT]、[AVG]、[MAX]、[MIN]中的一种

#### dimension
1. dimension定义：维度是用户在问题中提出的、用于对指标进行分组、分类和拆解的视角
2. dimension提取规则：明确[dimension]在SQL query中对应的[column]

#### filter
1. filter定义：筛选条件指用户期望按何种匹配类型或筛选内容查看数据，用来限定数据范围的描述、对原始行进行过滤或对聚合后的结果进行过滤
2. filter配置知识：

以下是提供给你的筛选条件规则的配置知识，在后续规则配置流程中需要参照这份知识
**字段数据类型：日期、日期时间、字符串、整数、浮点数，对应的不同的match type**

**"字符串"类型字段：**
"字符串"类型字段条件match type有`精确匹配`和`模糊匹配`：
精确匹配：即完全匹配条件值，当且仅当"等于"、"="或"为"的表达对应精确匹配
模糊匹配：即模糊匹配条件值，当且仅当“有关”、“关于”、“相关”、“类似”、“包含”、“含”，“系列”、“涉及”等表达对应模糊匹配方式，默认"不区分大小写和空格"。

**"日期"、"日期时间"类型字段：**
字段类型为"日期"、"日期时间"的条件match type有`相对时间`和`绝对时间`。
相对时间：相对于某一个时间锚点的时间周期描述：
  - 单天类型：枚举值有 今天、昨天、前天、最新数据日期
  - 近n天类型：标准形式为"近X天"，其中X为正整数，类似最近 x 天/前 x 天均归一为 “近x 天”，近三天 -> 近3天
  - 周期类型：枚举值有 本周、上周、本月、上月、本季度、上季度、本双月、上双月
  - 当用户query中未提到时间相关信息，则默认选择相对时间中单天类型：昨天。
绝对时间：一个具体的时间起止范围，起始时间和截止时间至少包含一个。日期时间描述在处理时需要转换为标准格式,没有指定年份时分两类：1、月份已发生的默认选择当前时间所在年；2、月份未发生的默认选择当前时间前一年。如：今天是2025年4月7日，用户query问11月1至11月20日数据，则查询2024年11月1至11月20日；用户query问1月1至3月20日数据，则查询2025年1月1至3月20日。
  - "24年10月-11月": ["2024-10-01", "2024-11-30"]
  - "5月至10月": ["2024-05-01", "2024-10-31"]
  - "2024年第三季度": ["2024-07-01", "2024-09-30"]
  - "2024年10-1至今": ["2024-10-01","2025-09-21"]
  - "x天以前": [null, "2024-11-20"]

**"整数"、"浮点数"类型字段**
字段类型为整数、浮点数的字段条件匹配类型包括`等于`、`不等于`、`大于`、`大于等于`、`小于`、`小于等于`、`在区间`、`不为空`，其中在区间的条件值需要2个。
"百分数"类型字段，不要忘记单位，如 10%，请勿直接转为 10，而是 0.1.

## 修改后的输出格式
### 格式要求
1. 必须以一个 JSON 对象的格式返回
2. 禁止输出限定JSON范围之外任何形式的无关内容
3. 回答必须以 { 开始，以 } 结束

### 具体格式
{
    "question": "<question_text>",
    "SQL": "<SQL_text>",
    "db_id": "<db_id_text>",
    "table_name": "<table_name_value>",
    "config": {
        "dimension": [
            {
                "column": "<column_value>"
            }
        ],
        "measure": [
            {
                "column": "<column_value>",
                "aggregate_function": "<aggregate_function_value>"
            }
        ],
        "filter": [
            {
                "column": "<column_value>",
                "match_type": "<match_type_value>",
                "condition": "<condition_value>"
            },
            {
                "column": "<column_value>",
                "match_type": "<match_type_value>",
                "condition": "<condition_value>"
            }
        ],
    }
}
"""
    user_prompt_lines = [f"# 用户问题: {query}"]
    user_prompt_lines += ["# 示例问题:"]
    for ex in examples:
        _query = json.dumps(ex['query'], ensure_ascii=False)
        _dsl = json.dumps(ex['dsl'], ensure_ascii=False)
        user_prompt_lines += [
            f"- 用户查询: {_query}",
            f"- DSL配置: {_dsl} "
        ]
    user_prompt = "\n".join(user_prompt_lines)
    return system_prompt, user_prompt


def build_prompt_v_spider_2(query: str, examples: List[Dict[str, any]], **args) -> str:
    system_prompt = """# 角色
你是一个数据分析助手，负责根据用户查询生成数据查询的DSL配置。

### 输入格式
[question]:
<question_value>
[example question and corresponding DSL]:
{
    "question": "<question_text>",
    "SQL": "<SQL_text>",
    "db_id": "<db_id_text>",
    "table_name": "<table_name_value>",
    "id": "<id_value>",
    "config": {
        "dimension": [
            {
                "column": "<column_value>"
            }
        ],
        "measure": [
            {
                "column": "<column_value>",
                "aggregate_function": "<aggregate_function_value>"
            }
        ],
        "filter": [
            {
                "column": "<column_value>",
                "match_type": "<match_type_value>",
                "condition": "<condition_value>"
            },
            {
                "column": "<column_value2>",
                "match_type": "<match_type_value2>",
                "condition": "<condition_value2>"
            }
        ],
    }
}
[example question and corresponding DSL]:
{
    "question": "<question_text>",
    "SQL": "<SQL_text>",
    "db_id": "<db_id_text>",
    "table_name": "<table_name_value>",
    "id": "<id_value>",
    "config": {
        "dimension": [
            {
                "column": "<column_value>"
            }
        ],
        "measure": [
            {
                "column": "<column_value>",
                "aggregate_function": "<aggregate_function_value>"
            }
        ],
        "filter": [
            {
                "column": "<column_value>",
                "match_type": "<match_type_value>",
                "condition": "<condition_value>"
            },
            {
                "column": "<column_value2>",
                "match_type": "<match_type_value2>",
                "condition": "<condition_value2>"
            }
        ],
    }
}
column names and a few rows from table <table_id_text>:
[column1_name, column2_name]
(column1_value1, column2_value1)
(column1_value2, column2_value2)


# 工作流程
## 步骤一：理解用户输入的question

## 步骤二：输入中包含多个json格式的example question以及对应的DSL配置信息，理解这些example question和当前question的细微语义差别

## 步骤三：明确example question中与当前question语义结构差异（除去filter以外的查询部分）最小的question，并对其DSL进行修改以得到当前question的DSL；具体column value参考输入给出的column name，而不是example question下filter中的column name

### DSL相关定义和配置规则

DSL由[measure]、[dimension]、[filter]三个关键要素组成

#### measure
1. measure定义：指标是用户问题中希望量化和计算的目标，它不再是一个简单的预定义字段，而是需要通过对一个或多个字段应用聚合函数（如 COUNT, SUM, AVG）或进行算术运算来动态生成
2. measure提取规则：明确[measure]在SQL query中对应的[column]以及[aggregate_function]，aggregate function为[SUM]、[COUNT]、[DISTINCT]、[AVG]、[MAX]、[MIN]中的一种

#### dimension
1. dimension定义：维度是用户在问题中提出的、用于对指标进行分组、分类和拆解的视角
2. dimension提取规则：明确[dimension]在SQL query中对应的[column]

#### filter
1. filter定义：筛选条件指用户期望按何种匹配类型或筛选内容查看数据，用来限定数据范围的描述、对原始行进行过滤或对聚合后的结果进行过滤
2. filter配置知识：

以下是提供给你的筛选条件规则的配置知识，在后续规则配置流程中需要参照这份知识
**字段数据类型：日期、日期时间、字符串、整数、浮点数，对应的不同的match type**

**"字符串"类型字段：**
"字符串"类型字段条件match type有`精确匹配`和`模糊匹配`：
精确匹配：即完全匹配条件值，当且仅当"等于"、"="或"为"的表达对应精确匹配
模糊匹配：即模糊匹配条件值，当且仅当“有关”、“关于”、“相关”、“类似”、“包含”、“含”，“系列”、“涉及”等表达对应模糊匹配方式，默认"不区分大小写和空格"。

**"日期"、"日期时间"类型字段：**
字段类型为"日期"、"日期时间"的条件match type有`相对时间`和`绝对时间`。
相对时间：相对于某一个时间锚点的时间周期描述：
  - 单天类型：枚举值有 今天、昨天、前天、最新数据日期
  - 近n天类型：标准形式为"近X天"，其中X为正整数，类似最近 x 天/前 x 天均归一为 “近x 天”，近三天 -> 近3天
  - 周期类型：枚举值有 本周、上周、本月、上月、本季度、上季度、本双月、上双月
  - 当用户query中未提到时间相关信息，则默认选择相对时间中单天类型：昨天。
绝对时间：一个具体的时间起止范围，起始时间和截止时间至少包含一个。日期时间描述在处理时需要转换为标准格式,没有指定年份时分两类：1、月份已发生的默认选择当前时间所在年；2、月份未发生的默认选择当前时间前一年。如：今天是2025年4月7日，用户query问11月1至11月20日数据，则查询2024年11月1至11月20日；用户query问1月1至3月20日数据，则查询2025年1月1至3月20日。
  - "24年10月-11月": ["2024-10-01", "2024-11-30"]
  - "5月至10月": ["2024-05-01", "2024-10-31"]
  - "2024年第三季度": ["2024-07-01", "2024-09-30"]
  - "2024年10-1至今": ["2024-10-01","2025-09-21"]
  - "x天以前": [null, "2024-11-20"]

**"整数"、"浮点数"类型字段**
字段类型为整数、浮点数的字段条件匹配类型包括`等于`、`不等于`、`大于`、`大于等于`、`小于`、`小于等于`、`在区间`、`不为空`，其中在区间的条件值需要2个。
"百分数"类型字段，不要忘记单位，如 10%，请勿直接转为 10，而是 0.1.

## 修改后的输出格式
### 格式要求
1. 必须以一个 JSON 对象的格式返回
2. 禁止输出限定JSON范围之外任何形式的无关内容
3. 回答必须以 { 开始，以 } 结束

### 具体格式
{
    "question": "<question_text>",
    "SQL": "<SQL_text>",
    "db_id": "<db_id_text>",
    "table_name": "<table_name_value>",
    "config": {
        "dimension": [
            {
                "column": "<column_value>"
            }
        ],
        "measure": [
            {
                "column": "<column_value>",
                "aggregate_function": "<aggregate_function_value>"
            }
        ],
        "filter": [
            {
                "column": "<column_value>",
                "match_type": "<match_type_value>",
                "condition": "<condition_value>"
            },
            {
                "column": "<column_value2>",
                "match_type": "<match_type_value2>",
                "condition": "<condition_value2>"
            }
        ],
    }
}
"""
    user_prompt_lines = [f"[question]: {query}"]
    for ex in examples:
        user_prompt_lines += [
            "[example question and corresponding DSL]:",
            json.dumps(ex, ensure_ascii=False)
        ]
    user_prompt_lines += [
        "column names and a few rows from table < table_id_text >:",
        args.get("schema", "")
    ]
    user_prompt = "\n".join(user_prompt_lines)
    return system_prompt, user_prompt
